<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[滑稽大法]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%BB%91%E7%A8%BD%E5%A4%A7%E6%B3%95%2F</url>
    <content type="text"><![CDATA[滑稽大法1234LIUCUI滑稽已经替换成刘翠源地址：~/hexo/public/huaji/... 查看]]></content>
  </entry>
  <entry>
    <title><![CDATA[IPTV直播源下载]]></title>
    <url>%2F2018%2F07%2F30%2Fiptv%2F</url>
    <content type="text"><![CDATA[iptv直播源1234567-央视超清蓝光台-卫视超清蓝光台-地方台-综艺-电影-电视剧-等 点我下载]]></content>
      <tags>
        <tag>直播源</tag>
        <tag>电视</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度]]></title>
    <url>%2F2018%2F07%2F30%2F%E7%99%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[哈哈哈]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%93%88%E5%93%88%E5%93%88%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[404]]></title>
    <url>%2F2018%2F07%2F29%2F404%2F</url>
    <content type="text"><![CDATA[###页面找不到了]]></content>
  </entry>
  <entry>
    <title><![CDATA[liucui]]></title>
    <url>%2F2018%2F07%2F29%2Fliucui%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[刘翠]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%88%98%E7%BF%A0%2F</url>
    <content type="text"><![CDATA[title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags: title: liucuidate: 2018-07-29 21:49:55 tags:]]></content>
  </entry>
  <entry>
    <title><![CDATA[WEBGL驱动的音乐展示器 - Azusa]]></title>
    <url>%2F2017%2F06%2F01%2Fazusa%2F</url>
    <content type="text"><![CDATA[懒！所以直接把 README 粘贴上来啦。最近玩 osu 把手打断啦 qwq。 项目 github Azusa A WEBGL Audio Spectrum Music Visualizer. How to use webpack 1npm install azusa --save 1import Azusa from &apos;azusa&apos; example123456789101112131415const azusa = new Azusa(&#123; view: document.getElementById(&apos;app&apos;) as HTMLCanvasElement, subdivisionSize: 1024, cutEnd: 256&#125;);azusa.audio.load(testSound, undefined, (xhr: any) =&gt; &#123; console.log((xhr.loaded / xhr.total * 100) + &apos;% loaded&apos;);&#125;);azusa.audio.Volume = 0.5;window.addEventListener(&apos;resize&apos;, () =&gt; &#123; azusa.resize(window.innerWidth, window.innerHeight);&#125;) Click here to demo]]></content>
      <categories>
        <category>发布</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>发布</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步和网络Api发展史]]></title>
    <url>%2F2017%2F03%2F27%2Fjs%E5%BC%82%E6%AD%A5%E5%92%8C%E7%BD%91%E7%BB%9Capi%E5%8F%91%E5%B1%95%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[从ajax到fetch，从回调到async，滑稽带你领略js异步和网络Api发展史。仅仅是速览不会深入 js是事件驱动的语言，单进程单线程。js主线程中有一个Event Loop（事件循环）。 js运行顺序js先执行一遍所有js文件，然后进入Event Loop，等到有事件进入，就执行事件处理程序，执行完后再次回到Event Loop。 举个例子: 123456setTimeout(()=&gt;&#123; console.log("hello");&#125;,0);//死循环while(true)&#123;&#125; 如果你在浏览器中运行，页面会卡死（在一些浏览器中仍可以滚动），因为js不执行完，浏览器不会做任何响应。 上面的代码永远不会输出hello，因为setTimeout(...,0)，虽然是延时0ms，但还是会在下一个事件循环中被调用。 而后面的while循环是死循环，js引擎永远执行不完，所以不会进入事件循环的，也就永远执行不到timeout里的代码 更详细的介绍可在阮老师的博客中看见。 异步所以啥是异步呢？ 我们先讲异步的反义词同步。 同步就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。 比如你发出一个网络请求请求一个数据，程序一直等待数据返回，不返回就不继续执行，这就是同步。 异步要智能得多。在网络请求没有返回之前程序还会继续执行。 延迟一秒在不同语言中同步、异步的不同写法: JS 异步123456console.log(1);setTimeout(()=&gt;&#123; console.log(2);&#125;,1000);console.log(3);//输出 1 3 2 Java 同步123456System.out.print(1);//延迟1000msThread.sleep(1000);System.out.print(2);System.out.print(3);//输出 1 2 3 显然Java的同步跟符合人类的思想，顺序执行非常简单。 但JS的优势也特别明显，在延迟时程序不会卡死，而是继续执行下去。 回调（callback）回调是JS异步编程最常见的方式。 回调函数（callback）是什么？(逼乎) 12345function callback()&#123; console.log("hello");&#125;setTimeout(callback,1000); 上面的callback()就作为回调函数，在1000ms后会被调用。 Ajax回到我们的主题，运用最广泛的网络api ajax就是以回调方式使用的。 123456789101112131415var xmlhttp;xmlhttp=new XMLHttpRequest();//定义回调函数xmlhttp.onreadystatechange=function()&#123; //如果请求完成 且 返回状态码为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //输出内容 console.log(xmlhttp.responseText); &#125;&#125;xmlhttp.open("GET","https://about.huaji8.top/links.json",true/*异步运行*/);//发送xmlhttp.send(); 复制到浏览器console可以运行。 jquery封装的ajax写法要比原版简单的多，对这是原版。 ajax也可以同步运行，只要将XMLHttpRequest.open()最后一个参数改成false，就是同步运行，执行send()后浏览器会卡住，直到请求返回。 Promise （承诺）Promise是一种更高级的回调接口。 详细的介绍在这ECMAScript 6 入门，Promise的好处千千万，建议大家全部使用Promise，jquery的所有异步api也全部支持Promise ES6 原生支持 Promise ， 在不支持的浏览器上可以使用垫片库 es6-promise 下面是一个将setTimeout()改造成Promise的例子。 1234567891011121314151617181920//返回一个Promise 就可以无限then()啦 还可以用catch()捕获异常function setTimeoutP(ms)&#123; //创建Promise 如果成功就调用resolve，失败就调用reject return new Promise((resolve,reject)=&gt;&#123; setTimeout(resolve,ms); &#125;)&#125;setTimeoutP(1000).then(()=&gt;&#123; console.log('Hello'); // 返回Promise 可以在then()中继续执行 return setTimeoutP(1000);&#125;).then(()=&gt;&#123; console.log('world'); // 返回数据 可以在then()中获取 return 123;&#125;).then((r)=&gt;&#123; console.log(r);&#125;)//一秒后输出Hello fetchfetch 是新的网络api 基于 Promise 设计。在旧的浏览器上可以使用 isomorphic-fetch，这个api是 node 和 浏览器环境通用的，实现同构应用必备的库。 注：同构(isomorphic/universal)就是使前后端运行同一套代码的意思，后端一般是指 NodeJS 环境。 范例123fetch("https://about.huaji8.top/links.json") .then((e)=&gt;&#123;return e.json()&#125;) .then((e)=&gt;&#123;console.log(e)&#125;); 尝试在浏览器console中运行 Generator 函数Generator 函数 是 ES6 提供的语法，不过很快就被 ES2017 的 async 函数 代替，所以不多说了，感兴趣的可以看ECMAScript 6 入门 第一次看到 Generator 函数 是在 unity 中的协程，现在js也有这个语法了。 async 函数重头来了，这是目前最屌的写法，真正用同步的写法写异步程序。 async 实际是 Generator 函数 的语法糖， Generator 才是技术 我们继续拿上面建的 setTimeoutP() 举例。 123456789101112131415161718//返回一个Promisefunction setTimeoutP(ms)&#123; //创建Promise 如果成功就调用resolve，失败就调用reject return new Promise((resolve,reject)=&gt;&#123; setTimeout(resolve,ms); &#125;)&#125;async function asyncDelay()&#123; // await可以拿到Promise的返回值 let O = await fetch("https://about.huaji8.top/links.json") .then((e)=&gt;&#123;return e.json()&#125;) await setTimeoutP(1000) console.log(O); //一秒后输出 https://about.huaji8.top/links.json 内容&#125;asyncDelay(); 尝试在浏览器console中运行 async 异常处理async 可以以同步的方式编写异常处理。 123456789101112async function asyncDelay()&#123; try&#123; let O = await fetch("https://about.huaji8.top/links.json") .then((e)=&gt;&#123;return e.json()&#125;) &#125;catch(e)&#123; //输出异常 console.log(e) .... &#125; await setTimeoutP(1000) console.log(O);&#125; 是不是超级方便呢。 关于async的更多信息，可以查看ECMAScript 6 入门或MDN]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>技术</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web动画框架的初步设计]]></title>
    <url>%2F2017%2F03%2F22%2Fweb%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[我希望有一天webApp能够达到原生应用的用户体验。 最后证实是重复造轮子，人家还比我造的好太多，大家都散了吧。 （ 让我哭一会https://github.com/berzniz/react-overdrive 第一次写这么复杂的东西，我的语文水平我自己清楚，看不懂的可以直接到下面评论区夸我了。 缘起我是怎么喜欢上material design的？ 多半是因为这张炫酷的图。 哇！炫酷！流畅！ 我立即搜索material design的前端框架，发现没有一款可以实现这种效果的。 什么？？？？ 我大前端连区区一个动画都搞不定！！！ codepen上的虽然有类似的特效，但从复用性，性能等方面考虑都没有能作为框架的。 于是开始造轮之路。 效果初步实现的效果图： 效果可能不是很好，可能是因为没有调整动画曲线，不过这都是小问题。源码需要重构，不好意思拿出来。感兴趣的话可以联系我。 思路我们将前面的炫酷ui可以分成两部分。 上面这两个界面分开来的话，相信对各位前端大神都是小菜一碟的吧。 这个框架的思路就是用程序来自动补间。 我们在每个元素身上放个key。 先记录下所有被标记的元素的位置。 页面改变后将其自动补间到新的位置。包括高度宽度等css属性。 嗯，但这个补间怎么做？js？css transition？ 显然css transition是更高效的选择，要使用css transition的前提就是页面的转换不能破坏这个元素。 现有路由库如：react-router等，都是删掉原来的元素，填入新的元素，所以css transition是行不通的。 然而我选了一种特别极端的方法，添加一个布局层。 布局层 上图红色部分就是布局层，布局层没有显示，没有动画，由路由负责管理。 图片中有内容的元素是绝对定位的，存在在布局层之上，不受路由管理，称为Plane(面)。 用程序把Plane放在对应的布局层之上，设置高度宽度，加上css transition。当布局层发送改变时，刷新Plane的位置，高度，宽度，内容。这个过程中Plane是不会被重建的于是css transition就产生了补间动画。 得益于react的 vdom 和 jsx 我们可以按正常的方式写元素，然后把他们渲染在其他地方。 再说下这个站 这个站也有布局转换的过渡效果。 可以看到布局变化后，原来的元素并没有被清理，codepen上许多方案也有这种缺陷，页面一多，就会有很多元素，肯定不行。 这篇文章的方法会真正释放掉旧的元素，也算个优点。 结尾如果你有更好的方法欢迎与我讨论。 封面画师: 秋月]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>js</tag>
        <tag>html</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web动画框架的初步设计]]></title>
    <url>%2F2017%2F03%2F22%2Fqq%2F</url>
    <content type="text"><![CDATA[我希望有一天webApp能够达到原生应用的用户体验。 最后证实是重复造轮子，人家还比我造的好太多，大家都散了吧。 （ 让我哭一会https://github.com/berzniz/react-overdrive 第一次写这么复杂的东西，我的语文水平我自己清楚，看不懂的可以直接到下面评论区夸我了。 缘起我是怎么喜欢上material design的？ 多半是因为这张炫酷的图。 哇！炫酷！流畅！ 我立即搜索material design的前端框架，发现没有一款可以实现这种效果的。 什么？？？？ 我大前端连区区一个动画都搞不定！！！ codepen上的虽然有类似的特效，但从复用性，性能等方面考虑都没有能作为框架的。 于是开始造轮之路。 效果初步实现的效果图： 效果可能不是很好，可能是因为没有调整动画曲线，不过这都是小问题。源码需要重构，不好意思拿出来。感兴趣的话可以联系我。 思路我们将前面的炫酷ui可以分成两部分。 上面这两个界面分开来的话，相信对各位前端大神都是小菜一碟的吧。 这个框架的思路就是用程序来自动补间。 我们在每个元素身上放个key。 先记录下所有被标记的元素的位置。 页面改变后将其自动补间到新的位置。包括高度宽度等css属性。 嗯，但这个补间怎么做？js？css transition？ 显然css transition是更高效的选择，要使用css transition的前提就是页面的转换不能破坏这个元素。 现有路由库如：react-router等，都是删掉原来的元素，填入新的元素，所以css transition是行不通的。 然而我选了一种特别极端的方法，添加一个布局层。 布局层 上图红色部分就是布局层，布局层没有显示，没有动画，由路由负责管理。 图片中有内容的元素是绝对定位的，存在在布局层之上，不受路由管理，称为Plane(面)。 用程序把Plane放在对应的布局层之上，设置高度宽度，加上css transition。当布局层发送改变时，刷新Plane的位置，高度，宽度，内容。这个过程中Plane是不会被重建的于是css transition就产生了补间动画。 得益于react的 vdom 和 jsx 我们可以按正常的方式写元素，然后把他们渲染在其他地方。 再说下这个站 这个站也有布局转换的过渡效果。 可以看到布局变化后，原来的元素并没有被清理，codepen上许多方案也有这种缺陷，页面一多，就会有很多元素，肯定不行。 这篇文章的方法会真正释放掉旧的元素，也算个优点。 结尾如果你有更好的方法欢迎与我讨论。 封面画师: 秋月]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>js</tag>
        <tag>html</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取元素绝对位置]]></title>
    <url>%2F2017%2F03%2F20%2Fjs%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[众：哇！不会吧！博主你这都不会！ 我：我…我还真的不会。 今天搞事情想搞个react动画框架。需要获取元素的绝对位置。 百度： 不要和我说google 一样的货色 123456789101112//获取元素的纵坐标 function getTop(e)&#123; var offset=e.offsetTop; if(e.offsetParent!=null) offset+=getTop(e.offsetParent); return offset; &#125; //获取元素的横坐标 function getLeft(e)&#123; var offset=e.offsetLeft; if(e.offsetParent!=null) offset+=getLeft(e.offsetParent); return offset; &#125; 嗯 很合理嘛 Element.offsetTop + 递归。 可偶然发现这是获取元素在文档流中的位置，但 transform 属性是不会改变文档流中的位置的。好，我们换一个方法。结果百度 google翻了几页都是这一个方法 继续寻找，突然想到jq，试了一下jq的offset方法，完美支持 transform 属性，mmp。 经查看jq源码，方法如下： 123456789101112131415161718192021222324252627282930313233343536offset: function( options ) &#123; // Preserve chaining for setter if ( arguments.length ) &#123; return options === undefined ? this : this.each( function( i ) &#123; jQuery.offset.setOffset( this, options, i ); &#125; ); &#125; var doc, docElem, rect, win, elem = this[ 0 ]; if ( !elem ) &#123; return; &#125; // Return zeros for disconnected and hidden (display: none) elements (gh-2310) // Support: IE &lt;=11 only // Running getBoundingClientRect on a // disconnected node in IE throws an error if ( !elem.getClientRects().length ) &#123; return &#123; top: 0, left: 0 &#125;; &#125; rect = elem.getBoundingClientRect(); doc = elem.ownerDocument; docElem = doc.documentElement; win = doc.defaultView; return &#123; top: rect.top + win.pageYOffset - docElem.clientTop, left: rect.left + win.pageXOffset - docElem.clientLeft &#125;;&#125; 查阅mdn的 getBoundingClientRect() 词条。 Range.getBoundingClientRect() 返回一个 ClientRect 对象，该对象限定了选定的文档对象的内容，该方法返回了一个矩形，这个矩形包围了该文档对象中所有元素的边界矩形集合（译者注：关于边界矩形可以参考 Minimum Bouding Rectangles）。 以及 getClientRects() 返回值是ClientRect对象集合，该对象是与该元素相关的CSS边框。每个ClientRect对象包含一组描述该边框的只读属性——left、top、right和bottom，单位为像素，这些属性值是相对于视口的top-left的。即使当表格的标题在表格的边框外面，该标题仍会被计算在内。 注意上文的 这些属性值是相对于视口的top-left的。 也就是说算出元素在页面的绝对位置还有加上视口滚动的距离。 所以jq的实现就是： 1234&#123; top: 元素顶部到视口顶部 + 视口到页面顶部 - 文档偏移 left: 元素左侧到视口左侧 + 视口到页面左侧 - 文档偏移&#125; 封面画师: squidsmith]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>js</tag>
        <tag>html</tag>
      </tags>
  </entry>
</search>
